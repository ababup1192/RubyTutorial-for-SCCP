# 課外プロジェクト 2015 実践的プログラミング II
2015 10/29 渡部未来・齊藤智博
資料URL:

## 1 はじめに
### 1.1 言語の歴史
既に知っている人も居るかもしれないが、Rubyは日本人、まつもとゆきひろ(通称Matz)の手によって開発されたオブジェクト指向スクリプト言語である。現在C言語を受講している受講生にとってはオブジェクト指向だとかスクリプト言語はまだまだ聞きなれない言葉かもしれない。しかし、2年生前期・後期で習うJAVA1やC++は、両方ともオブジェクト指向言語である。授業で習うまでの事前知識として今から頭に入れておいても損は無いだろう。

### 1.2 対話型シェル REPL
今まで授業でC言語を触ってきて、あるライブラリの関数の仕様を知りたい！といった時に苦労した経験は無いだろうか？ある関数の挙動を試す時に、変数宣言、目的の関数呼び出し、ソースコード保存、コンパイル、実行、出力確認...そこまでやって間違えていてまた最初からやり直しなどと言った日にはディスプレイを窓から投げ捨てて帰宅したくなるものだ。  
そんな時、Rubyプログラマーは、対話型Rubyシェルを用いることができる。これはREPL(Read-eval-print loop, れぷる)と呼ばれており、英単語から分かる通り、読んで(read)、評価して(eval)、表示して(print)、繰り返す(loop)シェルプログラムである。コードをシェルに打ち込むと直ちにそれを評価し表示してくれるので、前出のC言語の時のような関数の挙動を確かめたりしたい時などに重宝する。  
さて、実際にREPLを起動してみよう。ターミナル上で以下のコマンドを打ち込むことによって起動出来る。  

    $ irb
下のような文字がコンソール上に表示されたら起動した証拠だ。

    irb(main):001:0>
それでは実際にシェル上に

    irb(main):001:0> 1+1
と打ち込んでみよう。

    => 2
と結果が返ってくるはずだ。これだけではただの計算機だが、Rubyの基本構文等は全てこのREPL上で実行、表示する事が出来る。もちろんテキストファイルを作成しコードを記述してコンパイル、と言った手順でも動作確認が可能だが、今後の章で紹介するコードは殆ど小規模な物なのでREPL上で動作を確認した方が手軽で良いだろう。  
終了するにはCtrl-Dを入力するか、exitまたはquitとキーボードから入力すれば良い。  

## 2 制御式
### 2.1 式とは？
C言語の制御「文」とは違い、rubyでは制御「式」と言う呼び方が使われている。

### 2.2 if式
#### 2.2.1 構文
　rubyにおけるif式の基本的な構文は以下の形になる。

    if [条件式] then
	  [被制御式]
	end
条件式と被制御式部分が明確に分離可能な場合はthenは省略出来る。先の章で式とは値を返す物だと説明したが、if式の場合は被制御式の最後に評価された式の値を返す。

複数の条件分けが必要な条件分岐には、C言語で言った所の*else if* 節である*elsif* 節(*els*"*e*"*if*ではないことに注意！) を使おう。

    if [条件式1] then
      [被制御式1]
	elsif [条件式2] then
	  [被制御式2]
    elsif ...
	  ...
    else
      [被制御式n]
    end
　二つの構文を見て気付いたと思うが、C言語で言う節の境界にある中カッコ{ }が必要なくなり、更にif式の末尾には*end*が追加されていることに注意して欲しい。
  もし条件分岐先の処理が至極単純であり、長々とif式を書くのが煩わしいと感じる人はif修飾子を用いて

    [処理] if [被制御式]
と書くことも可能である。
また、rubyにはunless式という制御構文が実装されており、その名の通り条件式が偽の時に被制御式を評価する。
こちらは以下のような書き方が出来る。

    unless [条件式] then
	  [被制御式]
	end
この構文にはelseはあるものの、elsunlessという表記は存在しないことに注意して欲しい。また、if式と同じく簡単な処理を記載する際はunless修飾子を使うことが出来る。

    [被制御式] unless [条件式]

#### 2.2.2 コード例とC言語のif文との違い
簡単な問題を例にif式の使い方を紹介しよう。
例えば、与えられた整数a, bの等号成立判定をC言語のif文を用いて回答する場合、大半の人は以下のような書き方をするだろう。

	if(a == b){
	  printf("a = b\n");
    }
	else{
	  printf("a != b\n");
	}
これはC言語におけるifが"文"である事に忠実な書き方だが、rubyにおけるifは"式"であり、"値を返す"という事を考慮すると、rubyでは以下のような書き方をする事が出来る。

    print(
	  if a == b then "a = b"
	  else "a != b"
	  end
	)
また、前節最後で紹介したif修飾子を用いた書き方をすると、よりスマートな書き方が可能になる。

    print "a = b" if a == b
    print "a != b" unless a == b
ここまでなんとなく理解出来たという人は、ぜひ理解を確実な物とする為にAOJのこの問題を今紹介した手法を用いて解いてみると良いだろう。
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ITP1_2_A

### 2.3 case式
#### 2.3.1 構文
rubyにおけるcase式とは、C言語におけるswitch-case文に相当するものであり、値による多岐分岐を提供してくれている。基本的な構文は以下の形になる。

    case [変数]
	when [値] then
	  [処理]
	when [値] then
	  [処理]
	...
	else
	  [処理]
	end
上のcase式では、まずcaseの後に置かれた[変数]が評価され、次にその値に対応するwhen節が選ばれた後にthen節が実行され、最後にはif式と同じく最後に評価された式がcase式全体の値になり、返却される。また、このcase式もif式と同じく、区切りが明確であればthenは省略可能である。
case式にはさらに手を加えた範囲マッチングや正規表現マッチングが可能となっており、次の節では範囲マッチングを用いた例を紹介する。

#### 2.3.2 コード例とC言語のswitch-case文との違い
case式は実に様々な機能を持っているがここではよく使う基本的なcase式の例を挙げよう。
例えば、与えられたchar型inputが数字なのか英字どちらかをC言語のswitch-case文で確認する場合、以下のような書き方が出来る。

	switch(input){
	  case '0':
	  case '1':
	  ...
	  case '9':
	    printf("inputは数字\n");
		break;
	  case 'a':
	  case 'b':
	  ...
	  case 'z':
	    printf("inputは英字\n");
		break;
	  default:
	    printf("inputはその他の文字\n");
		break;
	}

rubyの場合でも同じような書き方が出来るが、ここではrubyの機能である範囲マッチングを試してみよう。if式と同じくcase式も値を返すことを考慮すると、コードは以下のようになる。

	print(
      case x
      when 0..9 then
	    "inputは数字\n"
      when a..z then
        "inputは英字\n"
      else
        "inputはその他の文字\n"
      end
	)
ここで初めて登場する0..9という書き方は、rubyのRange型である。今の時点では".."で挟まれた連続する数字あるいは英字を全て保持していると考えて貰って問題ない。
ここで、一見するとRange型である"0...9"は、inputに保持されているであろう数字または英字1文字とは比較出来ないように思えるが、rubyでは可能である。これを範囲マッチングと言い、数字の桁数の比較の際などに用いられる。

### 2.4 while式
#### 2.4.1 構文
C言語でも登場したループを表す制御構文のうち、本節ではwhlie式を紹介する。while式はrubyの中で最も単純な繰り返し構造であり、条件式が成立している間、被制御ぶの式を繰り返し評価し続ける。while式は以下のように書くことが出来る。

    while [条件式] do
      [被制御部]
    end
被制御部とは実際に繰り返し処理してほしい動作を記述する部分である。こちらに描かれているdoも、条件式と被制御部が明確に区別できる場合は省略可能となっている。

if式などと同様に、while式にもwhile修飾子が存在している。

    [被制御部] while [条件式]
こちらも通常のwhile式と同じく、条件が成立している間被制御部の式を繰り返し評価する。
授業や演習では詳しく習わなかったかもしれないが、C言語で言うdo_whileに対応する制御文もrubyには存在する。こちらは名前が後置whileと名前が変わっているが、動作そのものはC言語と全く同じである。構文は以下になる。

    begin
      [被制御部]
    end while [条件式]
このように記述する事によって、コード中に存在する被制御部は最低一回実行されてから、条件式の条件が成立しているか評価が行われ、通常のwhileループと同じ動きをするようになる。通常のwhile文と比べると、どちらかというとwhile修飾子をうまく用いているような構造をしているが、これは別物と考えたほうが良いだろう。
if文にもunlessという否定形の構文が存在したが、whileにもuntilと呼ばれている制御文が存在する。

    until [条件式]
	  [被制御部]
	end
これはwhileの条件文の判断基準とは真逆に、条件文が成立していない間被制御部を繰り返し評価する。もちろんこちらの方にもdo_until及びuntil修飾子が存在する。こちらは以下のように書ける。

    # do_until
    begin
	  [被制御部]
	end until [条件式]

	# until修飾子
	[被制御部] until [条件式]

ここまでwhile式の構文を提示してきたが、while"式"という言葉なのにもかかわらず、今まで式として返す値について言及しなかったのには理由がある。実はrubyにおけるwhile式は確かに値を返しているのだが、nilという値を返している。このnilというものはオブジェクトが存在しないことを示しているのだが、これでは今までのように構文を値として使うことが出来ない。今の段階では不便に感じることは無いかもしれないが、オブジェクト指向に於いて意味のある値を返さない関数というのは副作用がある関数と言い、あまり推奨されていない。
すぐにとは言わないが、rubyではなるべくwhile式を用いないようなコーディングを心がけるようにしよう。

#### 2.4.2 コード例
この節ではwhileの基本的な使い方をAOJの問題を例に紹介しよう。一番単純な問題としては、AOJのITPの「Print many hello world」が良い例だろう。rubyでの模範的な回答は以下になる。

    # while式を用いた解法
    i = 0
	while i < 1000
      print "Hello World\n"
      i = i+1
	end

	# until式を用いた解法
	i = 1000
	until i > 0
	  print "Hello World\n"
	  i = i-1
	end

### 2.5 for式
#### 2.5.1 構文
前節で紹介したwhile式と同様に、繰り返しの代表的な構造が本節で紹介するfor式だ。この式はC言語などで用いる場面と同じく、配列の操作などに長けている。以下にその構文を示そう。

    for [変数] in [オブジェクト] do
	  [被制御部]
	end
inの後にある[オブジェクト]にはRange型や配列そのものが入る。for式ではあらかじめ指定したオブジェクトから要素を全て取り出すと繰り返しは終了するので、特に終了条件をこちらから与えてあげる必要はない。

C言語と違い、rubyのfor文は繰り返し処理の制御構造に於いてそこまで重要な立ち位置を占めていない。と言うのも、for式の中でも実際にはイテレータを呼び出しており、より繰り返し構造を深く理解するにはイテレータを理解した方が良いだろう。

#### 2.5.2 コード例
実際にfor文を用いて繰り返し処理を実行してみよう。
例えば、1から10までの和を求めるfor式は以下のようになる。

    sum = 0
    for i in 1..10 do
	  sum = i + 1
	end

## 参考資料
初めてのRuby O'REILLY Japan　Yugui著
http://www.oki-osk.jp/esc/ruby/tut-01.html
http://docs.ruby-lang.org/ja/2.0.0/doc/index.html　
